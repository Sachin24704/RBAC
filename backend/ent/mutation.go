// Code generated by ent, DO NOT EDIT.

package ent

import (
	"backend/ent/model"
	"backend/ent/operation"
	"backend/ent/predicate"
	"backend/ent/role"
	"backend/ent/roleoperation"
	"backend/ent/user"
	"backend/ent/userrole"
	"context"
	"errors"
	"fmt"
	"sync"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeModel         = "Model"
	TypeOperation     = "Operation"
	TypeRole          = "Role"
	TypeRoleOperation = "RoleOperation"
	TypeUser          = "User"
	TypeUserRole      = "UserRole"
)

// ModelMutation represents an operation that mutates the Model nodes in the graph.
type ModelMutation struct {
	config
	op                Op
	typ               string
	id                *int
	name              *string
	clearedFields     map[string]struct{}
	operations        map[int]struct{}
	removedoperations map[int]struct{}
	clearedoperations bool
	done              bool
	oldValue          func(context.Context) (*Model, error)
	predicates        []predicate.Model
}

var _ ent.Mutation = (*ModelMutation)(nil)

// modelOption allows management of the mutation configuration using functional options.
type modelOption func(*ModelMutation)

// newModelMutation creates new mutation for the Model entity.
func newModelMutation(c config, op Op, opts ...modelOption) *ModelMutation {
	m := &ModelMutation{
		config:        c,
		op:            op,
		typ:           TypeModel,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withModelID sets the ID field of the mutation.
func withModelID(id int) modelOption {
	return func(m *ModelMutation) {
		var (
			err   error
			once  sync.Once
			value *Model
		)
		m.oldValue = func(ctx context.Context) (*Model, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Model.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withModel sets the old Model of the mutation.
func withModel(node *Model) modelOption {
	return func(m *ModelMutation) {
		m.oldValue = func(context.Context) (*Model, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ModelMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ModelMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ModelMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ModelMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Model.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *ModelMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ModelMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Model entity.
// If the Model object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModelMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ModelMutation) ResetName() {
	m.name = nil
}

// AddOperationIDs adds the "operations" edge to the Operation entity by ids.
func (m *ModelMutation) AddOperationIDs(ids ...int) {
	if m.operations == nil {
		m.operations = make(map[int]struct{})
	}
	for i := range ids {
		m.operations[ids[i]] = struct{}{}
	}
}

// ClearOperations clears the "operations" edge to the Operation entity.
func (m *ModelMutation) ClearOperations() {
	m.clearedoperations = true
}

// OperationsCleared reports if the "operations" edge to the Operation entity was cleared.
func (m *ModelMutation) OperationsCleared() bool {
	return m.clearedoperations
}

// RemoveOperationIDs removes the "operations" edge to the Operation entity by IDs.
func (m *ModelMutation) RemoveOperationIDs(ids ...int) {
	if m.removedoperations == nil {
		m.removedoperations = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.operations, ids[i])
		m.removedoperations[ids[i]] = struct{}{}
	}
}

// RemovedOperations returns the removed IDs of the "operations" edge to the Operation entity.
func (m *ModelMutation) RemovedOperationsIDs() (ids []int) {
	for id := range m.removedoperations {
		ids = append(ids, id)
	}
	return
}

// OperationsIDs returns the "operations" edge IDs in the mutation.
func (m *ModelMutation) OperationsIDs() (ids []int) {
	for id := range m.operations {
		ids = append(ids, id)
	}
	return
}

// ResetOperations resets all changes to the "operations" edge.
func (m *ModelMutation) ResetOperations() {
	m.operations = nil
	m.clearedoperations = false
	m.removedoperations = nil
}

// Where appends a list predicates to the ModelMutation builder.
func (m *ModelMutation) Where(ps ...predicate.Model) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ModelMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ModelMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Model, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ModelMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ModelMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Model).
func (m *ModelMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ModelMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, model.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ModelMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case model.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ModelMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case model.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Model field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ModelMutation) SetField(name string, value ent.Value) error {
	switch name {
	case model.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Model field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ModelMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ModelMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ModelMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Model numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ModelMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ModelMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ModelMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Model nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ModelMutation) ResetField(name string) error {
	switch name {
	case model.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Model field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ModelMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.operations != nil {
		edges = append(edges, model.EdgeOperations)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ModelMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case model.EdgeOperations:
		ids := make([]ent.Value, 0, len(m.operations))
		for id := range m.operations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ModelMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedoperations != nil {
		edges = append(edges, model.EdgeOperations)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ModelMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case model.EdgeOperations:
		ids := make([]ent.Value, 0, len(m.removedoperations))
		for id := range m.removedoperations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ModelMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedoperations {
		edges = append(edges, model.EdgeOperations)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ModelMutation) EdgeCleared(name string) bool {
	switch name {
	case model.EdgeOperations:
		return m.clearedoperations
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ModelMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Model unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ModelMutation) ResetEdge(name string) error {
	switch name {
	case model.EdgeOperations:
		m.ResetOperations()
		return nil
	}
	return fmt.Errorf("unknown Model edge %s", name)
}

// OperationMutation represents an operation that mutates the Operation nodes in the graph.
type OperationMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	name                   *string
	clearedFields          map[string]struct{}
	model                  *int
	clearedmodel           bool
	role_operations        map[int]struct{}
	removedrole_operations map[int]struct{}
	clearedrole_operations bool
	done                   bool
	oldValue               func(context.Context) (*Operation, error)
	predicates             []predicate.Operation
}

var _ ent.Mutation = (*OperationMutation)(nil)

// operationOption allows management of the mutation configuration using functional options.
type operationOption func(*OperationMutation)

// newOperationMutation creates new mutation for the Operation entity.
func newOperationMutation(c config, op Op, opts ...operationOption) *OperationMutation {
	m := &OperationMutation{
		config:        c,
		op:            op,
		typ:           TypeOperation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOperationID sets the ID field of the mutation.
func withOperationID(id int) operationOption {
	return func(m *OperationMutation) {
		var (
			err   error
			once  sync.Once
			value *Operation
		)
		m.oldValue = func(ctx context.Context) (*Operation, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Operation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOperation sets the old Operation of the mutation.
func withOperation(node *Operation) operationOption {
	return func(m *OperationMutation) {
		m.oldValue = func(context.Context) (*Operation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OperationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OperationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OperationMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OperationMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Operation.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *OperationMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *OperationMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Operation entity.
// If the Operation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OperationMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *OperationMutation) ResetName() {
	m.name = nil
}

// SetModelID sets the "model_id" field.
func (m *OperationMutation) SetModelID(i int) {
	m.model = &i
}

// ModelID returns the value of the "model_id" field in the mutation.
func (m *OperationMutation) ModelID() (r int, exists bool) {
	v := m.model
	if v == nil {
		return
	}
	return *v, true
}

// OldModelID returns the old "model_id" field's value of the Operation entity.
// If the Operation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OperationMutation) OldModelID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModelID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModelID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModelID: %w", err)
	}
	return oldValue.ModelID, nil
}

// ResetModelID resets all changes to the "model_id" field.
func (m *OperationMutation) ResetModelID() {
	m.model = nil
}

// ClearModel clears the "model" edge to the Model entity.
func (m *OperationMutation) ClearModel() {
	m.clearedmodel = true
	m.clearedFields[operation.FieldModelID] = struct{}{}
}

// ModelCleared reports if the "model" edge to the Model entity was cleared.
func (m *OperationMutation) ModelCleared() bool {
	return m.clearedmodel
}

// ModelIDs returns the "model" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ModelID instead. It exists only for internal usage by the builders.
func (m *OperationMutation) ModelIDs() (ids []int) {
	if id := m.model; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetModel resets all changes to the "model" edge.
func (m *OperationMutation) ResetModel() {
	m.model = nil
	m.clearedmodel = false
}

// AddRoleOperationIDs adds the "role_operations" edge to the RoleOperation entity by ids.
func (m *OperationMutation) AddRoleOperationIDs(ids ...int) {
	if m.role_operations == nil {
		m.role_operations = make(map[int]struct{})
	}
	for i := range ids {
		m.role_operations[ids[i]] = struct{}{}
	}
}

// ClearRoleOperations clears the "role_operations" edge to the RoleOperation entity.
func (m *OperationMutation) ClearRoleOperations() {
	m.clearedrole_operations = true
}

// RoleOperationsCleared reports if the "role_operations" edge to the RoleOperation entity was cleared.
func (m *OperationMutation) RoleOperationsCleared() bool {
	return m.clearedrole_operations
}

// RemoveRoleOperationIDs removes the "role_operations" edge to the RoleOperation entity by IDs.
func (m *OperationMutation) RemoveRoleOperationIDs(ids ...int) {
	if m.removedrole_operations == nil {
		m.removedrole_operations = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.role_operations, ids[i])
		m.removedrole_operations[ids[i]] = struct{}{}
	}
}

// RemovedRoleOperations returns the removed IDs of the "role_operations" edge to the RoleOperation entity.
func (m *OperationMutation) RemovedRoleOperationsIDs() (ids []int) {
	for id := range m.removedrole_operations {
		ids = append(ids, id)
	}
	return
}

// RoleOperationsIDs returns the "role_operations" edge IDs in the mutation.
func (m *OperationMutation) RoleOperationsIDs() (ids []int) {
	for id := range m.role_operations {
		ids = append(ids, id)
	}
	return
}

// ResetRoleOperations resets all changes to the "role_operations" edge.
func (m *OperationMutation) ResetRoleOperations() {
	m.role_operations = nil
	m.clearedrole_operations = false
	m.removedrole_operations = nil
}

// Where appends a list predicates to the OperationMutation builder.
func (m *OperationMutation) Where(ps ...predicate.Operation) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OperationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OperationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Operation, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OperationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OperationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Operation).
func (m *OperationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OperationMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.name != nil {
		fields = append(fields, operation.FieldName)
	}
	if m.model != nil {
		fields = append(fields, operation.FieldModelID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OperationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case operation.FieldName:
		return m.Name()
	case operation.FieldModelID:
		return m.ModelID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OperationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case operation.FieldName:
		return m.OldName(ctx)
	case operation.FieldModelID:
		return m.OldModelID(ctx)
	}
	return nil, fmt.Errorf("unknown Operation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OperationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case operation.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case operation.FieldModelID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModelID(v)
		return nil
	}
	return fmt.Errorf("unknown Operation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OperationMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OperationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OperationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Operation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OperationMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OperationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OperationMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Operation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OperationMutation) ResetField(name string) error {
	switch name {
	case operation.FieldName:
		m.ResetName()
		return nil
	case operation.FieldModelID:
		m.ResetModelID()
		return nil
	}
	return fmt.Errorf("unknown Operation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OperationMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.model != nil {
		edges = append(edges, operation.EdgeModel)
	}
	if m.role_operations != nil {
		edges = append(edges, operation.EdgeRoleOperations)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OperationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case operation.EdgeModel:
		if id := m.model; id != nil {
			return []ent.Value{*id}
		}
	case operation.EdgeRoleOperations:
		ids := make([]ent.Value, 0, len(m.role_operations))
		for id := range m.role_operations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OperationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedrole_operations != nil {
		edges = append(edges, operation.EdgeRoleOperations)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OperationMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case operation.EdgeRoleOperations:
		ids := make([]ent.Value, 0, len(m.removedrole_operations))
		for id := range m.removedrole_operations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OperationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedmodel {
		edges = append(edges, operation.EdgeModel)
	}
	if m.clearedrole_operations {
		edges = append(edges, operation.EdgeRoleOperations)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OperationMutation) EdgeCleared(name string) bool {
	switch name {
	case operation.EdgeModel:
		return m.clearedmodel
	case operation.EdgeRoleOperations:
		return m.clearedrole_operations
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OperationMutation) ClearEdge(name string) error {
	switch name {
	case operation.EdgeModel:
		m.ClearModel()
		return nil
	}
	return fmt.Errorf("unknown Operation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OperationMutation) ResetEdge(name string) error {
	switch name {
	case operation.EdgeModel:
		m.ResetModel()
		return nil
	case operation.EdgeRoleOperations:
		m.ResetRoleOperations()
		return nil
	}
	return fmt.Errorf("unknown Operation edge %s", name)
}

// RoleMutation represents an operation that mutates the Role nodes in the graph.
type RoleMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	name                   *string
	clearedFields          map[string]struct{}
	user_roles             map[int]struct{}
	removeduser_roles      map[int]struct{}
	cleareduser_roles      bool
	role_operations        map[int]struct{}
	removedrole_operations map[int]struct{}
	clearedrole_operations bool
	done                   bool
	oldValue               func(context.Context) (*Role, error)
	predicates             []predicate.Role
}

var _ ent.Mutation = (*RoleMutation)(nil)

// roleOption allows management of the mutation configuration using functional options.
type roleOption func(*RoleMutation)

// newRoleMutation creates new mutation for the Role entity.
func newRoleMutation(c config, op Op, opts ...roleOption) *RoleMutation {
	m := &RoleMutation{
		config:        c,
		op:            op,
		typ:           TypeRole,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRoleID sets the ID field of the mutation.
func withRoleID(id int) roleOption {
	return func(m *RoleMutation) {
		var (
			err   error
			once  sync.Once
			value *Role
		)
		m.oldValue = func(ctx context.Context) (*Role, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Role.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRole sets the old Role of the mutation.
func withRole(node *Role) roleOption {
	return func(m *RoleMutation) {
		m.oldValue = func(context.Context) (*Role, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RoleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RoleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RoleMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RoleMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Role.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *RoleMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *RoleMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *RoleMutation) ResetName() {
	m.name = nil
}

// AddUserRoleIDs adds the "user_roles" edge to the UserRole entity by ids.
func (m *RoleMutation) AddUserRoleIDs(ids ...int) {
	if m.user_roles == nil {
		m.user_roles = make(map[int]struct{})
	}
	for i := range ids {
		m.user_roles[ids[i]] = struct{}{}
	}
}

// ClearUserRoles clears the "user_roles" edge to the UserRole entity.
func (m *RoleMutation) ClearUserRoles() {
	m.cleareduser_roles = true
}

// UserRolesCleared reports if the "user_roles" edge to the UserRole entity was cleared.
func (m *RoleMutation) UserRolesCleared() bool {
	return m.cleareduser_roles
}

// RemoveUserRoleIDs removes the "user_roles" edge to the UserRole entity by IDs.
func (m *RoleMutation) RemoveUserRoleIDs(ids ...int) {
	if m.removeduser_roles == nil {
		m.removeduser_roles = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.user_roles, ids[i])
		m.removeduser_roles[ids[i]] = struct{}{}
	}
}

// RemovedUserRoles returns the removed IDs of the "user_roles" edge to the UserRole entity.
func (m *RoleMutation) RemovedUserRolesIDs() (ids []int) {
	for id := range m.removeduser_roles {
		ids = append(ids, id)
	}
	return
}

// UserRolesIDs returns the "user_roles" edge IDs in the mutation.
func (m *RoleMutation) UserRolesIDs() (ids []int) {
	for id := range m.user_roles {
		ids = append(ids, id)
	}
	return
}

// ResetUserRoles resets all changes to the "user_roles" edge.
func (m *RoleMutation) ResetUserRoles() {
	m.user_roles = nil
	m.cleareduser_roles = false
	m.removeduser_roles = nil
}

// AddRoleOperationIDs adds the "role_operations" edge to the RoleOperation entity by ids.
func (m *RoleMutation) AddRoleOperationIDs(ids ...int) {
	if m.role_operations == nil {
		m.role_operations = make(map[int]struct{})
	}
	for i := range ids {
		m.role_operations[ids[i]] = struct{}{}
	}
}

// ClearRoleOperations clears the "role_operations" edge to the RoleOperation entity.
func (m *RoleMutation) ClearRoleOperations() {
	m.clearedrole_operations = true
}

// RoleOperationsCleared reports if the "role_operations" edge to the RoleOperation entity was cleared.
func (m *RoleMutation) RoleOperationsCleared() bool {
	return m.clearedrole_operations
}

// RemoveRoleOperationIDs removes the "role_operations" edge to the RoleOperation entity by IDs.
func (m *RoleMutation) RemoveRoleOperationIDs(ids ...int) {
	if m.removedrole_operations == nil {
		m.removedrole_operations = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.role_operations, ids[i])
		m.removedrole_operations[ids[i]] = struct{}{}
	}
}

// RemovedRoleOperations returns the removed IDs of the "role_operations" edge to the RoleOperation entity.
func (m *RoleMutation) RemovedRoleOperationsIDs() (ids []int) {
	for id := range m.removedrole_operations {
		ids = append(ids, id)
	}
	return
}

// RoleOperationsIDs returns the "role_operations" edge IDs in the mutation.
func (m *RoleMutation) RoleOperationsIDs() (ids []int) {
	for id := range m.role_operations {
		ids = append(ids, id)
	}
	return
}

// ResetRoleOperations resets all changes to the "role_operations" edge.
func (m *RoleMutation) ResetRoleOperations() {
	m.role_operations = nil
	m.clearedrole_operations = false
	m.removedrole_operations = nil
}

// Where appends a list predicates to the RoleMutation builder.
func (m *RoleMutation) Where(ps ...predicate.Role) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RoleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RoleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Role, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RoleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RoleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Role).
func (m *RoleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RoleMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, role.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RoleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case role.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RoleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case role.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Role field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case role.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Role field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RoleMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RoleMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Role numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RoleMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RoleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RoleMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Role nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RoleMutation) ResetField(name string) error {
	switch name {
	case role.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Role field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RoleMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user_roles != nil {
		edges = append(edges, role.EdgeUserRoles)
	}
	if m.role_operations != nil {
		edges = append(edges, role.EdgeRoleOperations)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RoleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case role.EdgeUserRoles:
		ids := make([]ent.Value, 0, len(m.user_roles))
		for id := range m.user_roles {
			ids = append(ids, id)
		}
		return ids
	case role.EdgeRoleOperations:
		ids := make([]ent.Value, 0, len(m.role_operations))
		for id := range m.role_operations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RoleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removeduser_roles != nil {
		edges = append(edges, role.EdgeUserRoles)
	}
	if m.removedrole_operations != nil {
		edges = append(edges, role.EdgeRoleOperations)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RoleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case role.EdgeUserRoles:
		ids := make([]ent.Value, 0, len(m.removeduser_roles))
		for id := range m.removeduser_roles {
			ids = append(ids, id)
		}
		return ids
	case role.EdgeRoleOperations:
		ids := make([]ent.Value, 0, len(m.removedrole_operations))
		for id := range m.removedrole_operations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RoleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser_roles {
		edges = append(edges, role.EdgeUserRoles)
	}
	if m.clearedrole_operations {
		edges = append(edges, role.EdgeRoleOperations)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RoleMutation) EdgeCleared(name string) bool {
	switch name {
	case role.EdgeUserRoles:
		return m.cleareduser_roles
	case role.EdgeRoleOperations:
		return m.clearedrole_operations
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RoleMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Role unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RoleMutation) ResetEdge(name string) error {
	switch name {
	case role.EdgeUserRoles:
		m.ResetUserRoles()
		return nil
	case role.EdgeRoleOperations:
		m.ResetRoleOperations()
		return nil
	}
	return fmt.Errorf("unknown Role edge %s", name)
}

// RoleOperationMutation represents an operation that mutates the RoleOperation nodes in the graph.
type RoleOperationMutation struct {
	config
	op                Op
	typ               string
	id                *int
	clearedFields     map[string]struct{}
	role              *int
	clearedrole       bool
	operations        *int
	clearedoperations bool
	done              bool
	oldValue          func(context.Context) (*RoleOperation, error)
	predicates        []predicate.RoleOperation
}

var _ ent.Mutation = (*RoleOperationMutation)(nil)

// roleoperationOption allows management of the mutation configuration using functional options.
type roleoperationOption func(*RoleOperationMutation)

// newRoleOperationMutation creates new mutation for the RoleOperation entity.
func newRoleOperationMutation(c config, op Op, opts ...roleoperationOption) *RoleOperationMutation {
	m := &RoleOperationMutation{
		config:        c,
		op:            op,
		typ:           TypeRoleOperation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRoleOperationID sets the ID field of the mutation.
func withRoleOperationID(id int) roleoperationOption {
	return func(m *RoleOperationMutation) {
		var (
			err   error
			once  sync.Once
			value *RoleOperation
		)
		m.oldValue = func(ctx context.Context) (*RoleOperation, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RoleOperation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRoleOperation sets the old RoleOperation of the mutation.
func withRoleOperation(node *RoleOperation) roleoperationOption {
	return func(m *RoleOperationMutation) {
		m.oldValue = func(context.Context) (*RoleOperation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RoleOperationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RoleOperationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RoleOperationMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RoleOperationMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().RoleOperation.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRoleID sets the "role_id" field.
func (m *RoleOperationMutation) SetRoleID(i int) {
	m.role = &i
}

// RoleID returns the value of the "role_id" field in the mutation.
func (m *RoleOperationMutation) RoleID() (r int, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRoleID returns the old "role_id" field's value of the RoleOperation entity.
// If the RoleOperation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleOperationMutation) OldRoleID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoleID: %w", err)
	}
	return oldValue.RoleID, nil
}

// ResetRoleID resets all changes to the "role_id" field.
func (m *RoleOperationMutation) ResetRoleID() {
	m.role = nil
}

// SetOperationID sets the "operation_id" field.
func (m *RoleOperationMutation) SetOperationID(i int) {
	m.operations = &i
}

// OperationID returns the value of the "operation_id" field in the mutation.
func (m *RoleOperationMutation) OperationID() (r int, exists bool) {
	v := m.operations
	if v == nil {
		return
	}
	return *v, true
}

// OldOperationID returns the old "operation_id" field's value of the RoleOperation entity.
// If the RoleOperation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleOperationMutation) OldOperationID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperationID: %w", err)
	}
	return oldValue.OperationID, nil
}

// ResetOperationID resets all changes to the "operation_id" field.
func (m *RoleOperationMutation) ResetOperationID() {
	m.operations = nil
}

// ClearRole clears the "role" edge to the Role entity.
func (m *RoleOperationMutation) ClearRole() {
	m.clearedrole = true
	m.clearedFields[roleoperation.FieldRoleID] = struct{}{}
}

// RoleCleared reports if the "role" edge to the Role entity was cleared.
func (m *RoleOperationMutation) RoleCleared() bool {
	return m.clearedrole
}

// RoleIDs returns the "role" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RoleID instead. It exists only for internal usage by the builders.
func (m *RoleOperationMutation) RoleIDs() (ids []int) {
	if id := m.role; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRole resets all changes to the "role" edge.
func (m *RoleOperationMutation) ResetRole() {
	m.role = nil
	m.clearedrole = false
}

// SetOperationsID sets the "operations" edge to the Operation entity by id.
func (m *RoleOperationMutation) SetOperationsID(id int) {
	m.operations = &id
}

// ClearOperations clears the "operations" edge to the Operation entity.
func (m *RoleOperationMutation) ClearOperations() {
	m.clearedoperations = true
	m.clearedFields[roleoperation.FieldOperationID] = struct{}{}
}

// OperationsCleared reports if the "operations" edge to the Operation entity was cleared.
func (m *RoleOperationMutation) OperationsCleared() bool {
	return m.clearedoperations
}

// OperationsID returns the "operations" edge ID in the mutation.
func (m *RoleOperationMutation) OperationsID() (id int, exists bool) {
	if m.operations != nil {
		return *m.operations, true
	}
	return
}

// OperationsIDs returns the "operations" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OperationsID instead. It exists only for internal usage by the builders.
func (m *RoleOperationMutation) OperationsIDs() (ids []int) {
	if id := m.operations; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOperations resets all changes to the "operations" edge.
func (m *RoleOperationMutation) ResetOperations() {
	m.operations = nil
	m.clearedoperations = false
}

// Where appends a list predicates to the RoleOperationMutation builder.
func (m *RoleOperationMutation) Where(ps ...predicate.RoleOperation) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RoleOperationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RoleOperationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.RoleOperation, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RoleOperationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RoleOperationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (RoleOperation).
func (m *RoleOperationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RoleOperationMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.role != nil {
		fields = append(fields, roleoperation.FieldRoleID)
	}
	if m.operations != nil {
		fields = append(fields, roleoperation.FieldOperationID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RoleOperationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case roleoperation.FieldRoleID:
		return m.RoleID()
	case roleoperation.FieldOperationID:
		return m.OperationID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RoleOperationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case roleoperation.FieldRoleID:
		return m.OldRoleID(ctx)
	case roleoperation.FieldOperationID:
		return m.OldOperationID(ctx)
	}
	return nil, fmt.Errorf("unknown RoleOperation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleOperationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case roleoperation.FieldRoleID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoleID(v)
		return nil
	case roleoperation.FieldOperationID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperationID(v)
		return nil
	}
	return fmt.Errorf("unknown RoleOperation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RoleOperationMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RoleOperationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleOperationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown RoleOperation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RoleOperationMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RoleOperationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RoleOperationMutation) ClearField(name string) error {
	return fmt.Errorf("unknown RoleOperation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RoleOperationMutation) ResetField(name string) error {
	switch name {
	case roleoperation.FieldRoleID:
		m.ResetRoleID()
		return nil
	case roleoperation.FieldOperationID:
		m.ResetOperationID()
		return nil
	}
	return fmt.Errorf("unknown RoleOperation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RoleOperationMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.role != nil {
		edges = append(edges, roleoperation.EdgeRole)
	}
	if m.operations != nil {
		edges = append(edges, roleoperation.EdgeOperations)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RoleOperationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case roleoperation.EdgeRole:
		if id := m.role; id != nil {
			return []ent.Value{*id}
		}
	case roleoperation.EdgeOperations:
		if id := m.operations; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RoleOperationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RoleOperationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RoleOperationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedrole {
		edges = append(edges, roleoperation.EdgeRole)
	}
	if m.clearedoperations {
		edges = append(edges, roleoperation.EdgeOperations)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RoleOperationMutation) EdgeCleared(name string) bool {
	switch name {
	case roleoperation.EdgeRole:
		return m.clearedrole
	case roleoperation.EdgeOperations:
		return m.clearedoperations
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RoleOperationMutation) ClearEdge(name string) error {
	switch name {
	case roleoperation.EdgeRole:
		m.ClearRole()
		return nil
	case roleoperation.EdgeOperations:
		m.ClearOperations()
		return nil
	}
	return fmt.Errorf("unknown RoleOperation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RoleOperationMutation) ResetEdge(name string) error {
	switch name {
	case roleoperation.EdgeRole:
		m.ResetRole()
		return nil
	case roleoperation.EdgeOperations:
		m.ResetOperations()
		return nil
	}
	return fmt.Errorf("unknown RoleOperation edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                Op
	typ               string
	id                *int
	name              *string
	clearedFields     map[string]struct{}
	user_roles        map[int]struct{}
	removeduser_roles map[int]struct{}
	cleareduser_roles bool
	done              bool
	oldValue          func(context.Context) (*User, error)
	predicates        []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *UserMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UserMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *UserMutation) ResetName() {
	m.name = nil
}

// AddUserRoleIDs adds the "user_roles" edge to the UserRole entity by ids.
func (m *UserMutation) AddUserRoleIDs(ids ...int) {
	if m.user_roles == nil {
		m.user_roles = make(map[int]struct{})
	}
	for i := range ids {
		m.user_roles[ids[i]] = struct{}{}
	}
}

// ClearUserRoles clears the "user_roles" edge to the UserRole entity.
func (m *UserMutation) ClearUserRoles() {
	m.cleareduser_roles = true
}

// UserRolesCleared reports if the "user_roles" edge to the UserRole entity was cleared.
func (m *UserMutation) UserRolesCleared() bool {
	return m.cleareduser_roles
}

// RemoveUserRoleIDs removes the "user_roles" edge to the UserRole entity by IDs.
func (m *UserMutation) RemoveUserRoleIDs(ids ...int) {
	if m.removeduser_roles == nil {
		m.removeduser_roles = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.user_roles, ids[i])
		m.removeduser_roles[ids[i]] = struct{}{}
	}
}

// RemovedUserRoles returns the removed IDs of the "user_roles" edge to the UserRole entity.
func (m *UserMutation) RemovedUserRolesIDs() (ids []int) {
	for id := range m.removeduser_roles {
		ids = append(ids, id)
	}
	return
}

// UserRolesIDs returns the "user_roles" edge IDs in the mutation.
func (m *UserMutation) UserRolesIDs() (ids []int) {
	for id := range m.user_roles {
		ids = append(ids, id)
	}
	return
}

// ResetUserRoles resets all changes to the "user_roles" edge.
func (m *UserMutation) ResetUserRoles() {
	m.user_roles = nil
	m.cleareduser_roles = false
	m.removeduser_roles = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, user.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user_roles != nil {
		edges = append(edges, user.EdgeUserRoles)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeUserRoles:
		ids := make([]ent.Value, 0, len(m.user_roles))
		for id := range m.user_roles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removeduser_roles != nil {
		edges = append(edges, user.EdgeUserRoles)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeUserRoles:
		ids := make([]ent.Value, 0, len(m.removeduser_roles))
		for id := range m.removeduser_roles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser_roles {
		edges = append(edges, user.EdgeUserRoles)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeUserRoles:
		return m.cleareduser_roles
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeUserRoles:
		m.ResetUserRoles()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// UserRoleMutation represents an operation that mutates the UserRole nodes in the graph.
type UserRoleMutation struct {
	config
	op            Op
	typ           string
	id            *int
	clearedFields map[string]struct{}
	user          *int
	cleareduser   bool
	role          *int
	clearedrole   bool
	done          bool
	oldValue      func(context.Context) (*UserRole, error)
	predicates    []predicate.UserRole
}

var _ ent.Mutation = (*UserRoleMutation)(nil)

// userroleOption allows management of the mutation configuration using functional options.
type userroleOption func(*UserRoleMutation)

// newUserRoleMutation creates new mutation for the UserRole entity.
func newUserRoleMutation(c config, op Op, opts ...userroleOption) *UserRoleMutation {
	m := &UserRoleMutation{
		config:        c,
		op:            op,
		typ:           TypeUserRole,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserRoleID sets the ID field of the mutation.
func withUserRoleID(id int) userroleOption {
	return func(m *UserRoleMutation) {
		var (
			err   error
			once  sync.Once
			value *UserRole
		)
		m.oldValue = func(ctx context.Context) (*UserRole, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserRole.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserRole sets the old UserRole of the mutation.
func withUserRole(node *UserRole) userroleOption {
	return func(m *UserRoleMutation) {
		m.oldValue = func(context.Context) (*UserRole, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserRoleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserRoleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserRoleMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserRoleMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserRole.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *UserRoleMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserRoleMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserRole entity.
// If the UserRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserRoleMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserRoleMutation) ResetUserID() {
	m.user = nil
}

// SetRoleID sets the "role_id" field.
func (m *UserRoleMutation) SetRoleID(i int) {
	m.role = &i
}

// RoleID returns the value of the "role_id" field in the mutation.
func (m *UserRoleMutation) RoleID() (r int, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRoleID returns the old "role_id" field's value of the UserRole entity.
// If the UserRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserRoleMutation) OldRoleID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoleID: %w", err)
	}
	return oldValue.RoleID, nil
}

// ResetRoleID resets all changes to the "role_id" field.
func (m *UserRoleMutation) ResetRoleID() {
	m.role = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserRoleMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[userrole.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserRoleMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserRoleMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserRoleMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearRole clears the "role" edge to the Role entity.
func (m *UserRoleMutation) ClearRole() {
	m.clearedrole = true
	m.clearedFields[userrole.FieldRoleID] = struct{}{}
}

// RoleCleared reports if the "role" edge to the Role entity was cleared.
func (m *UserRoleMutation) RoleCleared() bool {
	return m.clearedrole
}

// RoleIDs returns the "role" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RoleID instead. It exists only for internal usage by the builders.
func (m *UserRoleMutation) RoleIDs() (ids []int) {
	if id := m.role; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRole resets all changes to the "role" edge.
func (m *UserRoleMutation) ResetRole() {
	m.role = nil
	m.clearedrole = false
}

// Where appends a list predicates to the UserRoleMutation builder.
func (m *UserRoleMutation) Where(ps ...predicate.UserRole) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserRoleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserRoleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserRole, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserRoleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserRoleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserRole).
func (m *UserRoleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserRoleMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.user != nil {
		fields = append(fields, userrole.FieldUserID)
	}
	if m.role != nil {
		fields = append(fields, userrole.FieldRoleID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserRoleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userrole.FieldUserID:
		return m.UserID()
	case userrole.FieldRoleID:
		return m.RoleID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserRoleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userrole.FieldUserID:
		return m.OldUserID(ctx)
	case userrole.FieldRoleID:
		return m.OldRoleID(ctx)
	}
	return nil, fmt.Errorf("unknown UserRole field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserRoleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userrole.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case userrole.FieldRoleID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoleID(v)
		return nil
	}
	return fmt.Errorf("unknown UserRole field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserRoleMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserRoleMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserRoleMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserRole numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserRoleMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserRoleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserRoleMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UserRole nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserRoleMutation) ResetField(name string) error {
	switch name {
	case userrole.FieldUserID:
		m.ResetUserID()
		return nil
	case userrole.FieldRoleID:
		m.ResetRoleID()
		return nil
	}
	return fmt.Errorf("unknown UserRole field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserRoleMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, userrole.EdgeUser)
	}
	if m.role != nil {
		edges = append(edges, userrole.EdgeRole)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserRoleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userrole.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case userrole.EdgeRole:
		if id := m.role; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserRoleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserRoleMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserRoleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, userrole.EdgeUser)
	}
	if m.clearedrole {
		edges = append(edges, userrole.EdgeRole)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserRoleMutation) EdgeCleared(name string) bool {
	switch name {
	case userrole.EdgeUser:
		return m.cleareduser
	case userrole.EdgeRole:
		return m.clearedrole
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserRoleMutation) ClearEdge(name string) error {
	switch name {
	case userrole.EdgeUser:
		m.ClearUser()
		return nil
	case userrole.EdgeRole:
		m.ClearRole()
		return nil
	}
	return fmt.Errorf("unknown UserRole unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserRoleMutation) ResetEdge(name string) error {
	switch name {
	case userrole.EdgeUser:
		m.ResetUser()
		return nil
	case userrole.EdgeRole:
		m.ResetRole()
		return nil
	}
	return fmt.Errorf("unknown UserRole edge %s", name)
}
